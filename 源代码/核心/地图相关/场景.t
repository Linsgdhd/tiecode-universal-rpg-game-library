/*
 行列 数据更新，是否可行  |  不可行
 这坨代码已经够屎了 不要写了 建议重构*
 ## 1、相机移动时，网格会出现缝隙，问题出在哪里？
*/
类 场景
	变量 场景id : 整数
	变量 场景名称 : 文本
	变量 高度 : 整数
	变量 宽度 : 整数
	变量 网格大小 : 整数 = 90
	变量 视图 : 相机?
	变量 数据管理 : 数据管理器
	变量 网格 : 格子[]?
	变量 建筑实体容器 : 集合
	变量 角色实体容器 : 集合
	变量 碰撞实体 : 集合
	变量 cursor : 光标
	变量 容器 : 场景实体容器
	变量 abyss : 世界?
	变量 jdata : JSON对象?
	变量 场景画笔 : 画笔
	变量 已完成初始化 : 逻辑型 = 假
	
	方法 是否位于弦上(目标 : 单精度小数,容许误差 : 单精度小数 = 0.0f) : 逻辑型
		返回 (数学.abs_float(目标 % 网格大小).到整数() <= 容许误差)
	结束 方法
	
	方法 取临近X弦(Y坐标 : 单精度小数) : 单精度小数
		返回 (Y坐标 / 网格大小).到整数() * 网格大小
	结束 方法
	
	方法 取临近Y弦(X坐标 : 单精度小数) : 单精度小数
		返回 (X坐标 / 网格大小).到整数() * 网格大小
	结束 方法
	
	方法 取临近网格(value : 场景实体) : 格子
		循环(i, 0, 取数组长度(网格))
		结束 循环
	结束 方法
	
	方法 实例化(data : JSON对象,world : 世界,camera : 相机)
		如果 取反(已完成初始化) 则
			数据更新()
		结束 如果
		加载进度更新(0)
		数据管理.初始化()
		abyss = world
		jdata = data
		高度 = data.取整数("height")
		宽度 = data.取整数("width")
		场景画笔.设置颜色(0xffff0000)
		场景画笔.设置画笔宽度(8.0f)
		视图 = camera
		加载进度更新(10)
		提交到新线程运行()
		变量 tempcells : 格子[高度*宽度]
		变量 tempjcl : JSON数组 = data.取JSON数组("cells")
		循环(i, 0, 取数组长度(tempcells))
			变量 tempcell : 格子
			tempcell.初始化(tempjcl.取JSON对象(i),本对象)
			tempcells[i] = tempcell
		结束 循环
		网格 = tempcells
		加载进度更新(30)
		变量 tempjel : JSON数组 = data.取JSON数组("entity")
		加载进度更新(60)
		循环(e, 0, tempjel.长度)
			变量 tempentity : 场景实体
			tempentity.初始化(tempjel.取JSON对象(e),本对象)
			// 建筑索引容器.添加成员(tempentity.row.到文本() +"v"+ tempentity.col.到文本())
			建筑实体容器.添加成员(tempentity)
		结束 循环
		cursor.初始化(本对象)
		已完成初始化 = 真
		加载进度更新(100)
		加载完成()
		订阅事件()
		结束提交到新线程()
	结束 方法

	方法 数据更新()
		提交到新线程运行()
		循环(真)
			延时(10)
			如果 已完成初始化 则
				循环(i, 0, 建筑实体容器.长度)
					变量 temp : 场景实体 = 建筑实体容器[i]
					temp.计数.tick()
				结束 循环
				循环(e, 0, 角色实体容器.长度)
					变量 tema : 场景实体 = 角色实体容器[e]
					tema.计数.tick()
					tema.更新数据()
				结束 循环
			结束 如果
			// 调试输出("sum" + 角色实体容器.长度.到文本())
			cursor.计数.tick()
		结束 循环
		结束提交到新线程()
	结束 方法

	方法 绘制(canvas : 画布)
		如果 已完成初始化 则
			循环(i, 0, 取数组长度(网格))
				变量 temp : 格子 = 网格[i]
				如果 视图.可绘制(temp.位置,网格大小,网格大小) 则
					canvas.绘制位图2(temp.背景图片,temp.位置.x - 视图.位置.x,temp.位置.y - 视图.位置.y,场景画笔)
				结束 如果
			结束 循环
			循环(o, 0, 建筑实体容器.长度)
				变量 temp : 场景实体 = 建筑实体容器.取成员(o)
				如果 视图.可绘制(temp.位置,网格大小,网格大小) 则
					canvas.绘制位图2(temp.取位图(),temp.位置.x - 视图.位置.x,temp.位置.y - 视图.位置.y,场景画笔)
				结束 如果
			结束 循环
			循环(e, 0, 角色实体容器.长度)
				变量 tems : 场景实体 = 角色实体容器.取成员(e)
				canvas.绘制位图2(tems.取位图(),tems.绘制起点x - 视图.位置.x,tems.绘制起点y - 视图.位置.y,场景画笔)
				canvas.绘制线条(0 - 视图.位置.x,tems.临近x弦 - 视图.位置.y,tems.临近y弦 - 视图.位置.x,tems.临近x弦 - 视图.位置.y,场景画笔)
			结束 循环
			canvas.绘制位图2(cursor.取位图(),cursor.位置.x - 视图.位置.x,cursor.位置.y - 视图.位置.y,场景画笔)
			视图.更新数据()
		结束 如果
	结束 方法
	
	方法 被触摸(x : 整数,y : 整数)
		变量 单击坐标 : rl坐标
		单击坐标.x = 视图.位置.x + x
		单击坐标.y = 视图.位置.y + y
		循环(i, 0, 取数组长度(网格))
			变量 temp : 格子 = 网格[i]
			如果(单击坐标.x <= temp.位置.x + 网格大小 且 单击坐标.x >= temp.位置.x 且 单击坐标.y <= temp.位置.y + 网格大小 且 单击坐标.y >= temp.位置.y)
				网格被单击(temp.被点击())
			结束 如果
		结束 循环
	结束 方法
	
	方法 碰撞检测(x : 单精度小数, y : 单精度小数, w : 单精度小数, h : 单精度小数)
		
	结束 方法
	
	方法 添加实体(data : JSON对象)
		调试输出("尝试初始化实体" + data.到文本(4))
		变量 临时实体 : 场景实体
		临时实体.初始化(data,本对象)
		如果 角色实体容器.长度 == 0 则
			视图.绑定场景实体(临时实体)
		结束 如果
		角色实体容器.添加成员(临时实体)
		调试输出("初始化完成 创建角色实体.."+ "当前实体数量:" + 角色实体容器.长度.到文本())
	结束 方法
	
	方法 添加实体2(data : 场景实体)
		
	结束 方法
	
	定义事件 加载完成()
	定义事件 加载进度更新(sum : 整数)
	定义事件 网格被单击(网格 : 格子)
结束 类

类 碰撞信息
	变量 上 : 逻辑型
	变量 下 : 逻辑型
	变量 左 : 逻辑型
	变量 右 : 逻辑型
结束 类

类 相机
	变量 高度 : 单精度小数 = 0.0f
	变量 宽度 : 单精度小数 = 0.0f
	变量 位置 : rl坐标
	变量 缓冲位置 : rl坐标
	变量 向量 : rl坐标
	变量 网格大小 : 单精度小数 = 0.0f
	变量 场景宽度 : 单精度小数 = 0.0f
	变量 场景高度 : 单精度小数 = 0.0f
	变量 用户输入 : 逻辑型 = 真
	变量 目标实体 : 场景实体
	变量 x轴曲线 : 曲线
	变量 y轴曲线 : 曲线
	
	方法 绑定场景实体(目标 : 场景实体)
		目标实体 = 目标
		对准坐标(目标实体.位置)
		订阅事件 目标实体
	结束 方法
	
	事件 目标实体 : 数据更新完成()
		变量 xe : 单精度小数 = 目标实体.位置.x + 网格大小 * 0.5f - 宽度 / 2
		变量 ye : 单精度小数 = 目标实体.位置.y + 网格大小 * 0.5f - 高度 / 2
		如果 位置.x != xe 且 用户输入 则
			缓冲位置.x = 缓冲位置.x + (xe - 位置.x) * 0.1f
		结束 如果
		如果 位置.y != ye 且 用户输入 则
			缓冲位置.y = 缓冲位置.y + (ye - 位置.y) * 0.1f
		结束 如果
	结束 事件
	
	方法 初始化(wgdx : 单精度小数,cjw : 整数,cjh : 整数)
		订阅事件()
		网格大小 = wgdx
		场景宽度 = cjw * 网格大小 - 宽度
		场景高度 = cjh * 网格大小 - 高度
	结束 方法
	
	方法 可绘制(xy : rl坐标,w : 单精度小数,h : 单精度小数) : 逻辑型
		返回 (xy.x <= 位置.x + 宽度 且 xy.x + w >= 位置.x 且 xy.y <= 位置.y + 高度 且 xy.y + h >= 位置.y)
	结束 方法
	
	方法 更新数据()
		位置.x = 缓冲位置.x
		位置.y = 缓冲位置.y
	结束 方法
	
	方法 对准坐标(目标 : rl坐标)
		如果 x轴曲线.播放中 或 y轴曲线.播放中 则
			返回
		结束 如果
		用户输入 = 假
		变量 xe : 单精度小数 = 目标.x - 宽度 / 2
		变量 ye : 单精度小数 = 目标.y - 高度 / 2
		x轴曲线.定义(位置.x,xe,曲线类型.快慢)
		y轴曲线.定义(位置.y,ye,曲线类型.快慢)
		变量 xee : 逻辑型 = 假
		变量 yee : 逻辑型 = 假
		事件 x轴曲线 : 输出值(value : 单精度小数)
			缓冲位置.x = value
		结束 事件
		事件 y轴曲线 : 输出值(value : 单精度小数)
			缓冲位置.y = value
		结束 事件
		事件 x轴曲线 : 播放完毕()
			用户输入 = 真
		结束 事件
		调试输出("调用完毕")
	结束 方法
结束 类


类 计数器
	变量 当前计数 : 整数
	变量 最大计数 : 整数 = 20
	方法 tick()
		自增(当前计数)
		如果 当前计数 >= 最大计数 则
			触发()
			当前计数 = 0
		结束 如果
	结束 方法
	定义事件 触发()
结束 类

@静态
类 角色动画类型
	@静态
	常量 站立_向前 : 整数 = 0
	@静态
	常量 站立_向后 : 整数 = 1
	@静态
	常量 站立_向左 : 整数 = 2
	@静态
	常量 站立_向右 : 整数 = 3
	@静态
	常量 移动_向前 : 整数 = 4
	@静态
	常量 移动_向后 : 整数 = 5
	@静态
	常量 移动_向左 : 整数 = 6
	@静态
	常量 移动_向右 : 整数 = 7
	@静态
	常量 跳跃_向前 : 整数 = 8
	@静态
	常量 跳跃_向后 : 整数 = 9
	@静态
	常量 跳跃_向左 : 整数 = 10
	@静态
	常量 跳跃_向右 : 整数 = 11
结束 类

类 位图容器
	变量 容器 : 集合
	变量 计数 : 整数
	变量 缓存 : 对象
	变量 拒绝访问 : 逻辑型 = 假
	方法 添加(数据 : 位图对象)
		容器.添加成员(数据)
	结束 方法
	方法 删除(索引 : 整数)
		容器.删除成员(索引)
	结束 方法
	方法 访问() : 位图对象
		如果 拒绝访问 则
			变量 temr : 位图对象 = 缓存
			返回 temr
		否则
			变量 temp : 位图对象 = 容器.取成员(计数)
			缓存 = temp
			返回 temp
		结束 如果
	结束 方法
	方法 下一张()
		如果 计数 >= 容器.长度 - 1 则
			重置计数器()
		否则
			自增(计数)
		结束 如果
	结束 方法
	方法 重置计数器()
		计数 = 0
	结束 方法
	方法 清空()
		拒绝访问 = 真
		重置计数器()
		容器.清空()
	结束 方法
	方法 长度() : 整数
		返回 容器.长度
	结束 方法
结束 类

类 场景实体容器
	变量 坐标集合 : 哈希表
	变量 容器 : 集合
	方法 添加场景实体(值 : 场景实体)
		容器.添加成员(值)
	结束 方法
结束 类

类 光标
	变量 位图序列 : 位图容器
	变量 计数 : 计数器
	变量 位置 : rl坐标
	变量 高度 : 单精度小数 = 0.0f
	变量 宽度 : 单精度小数 = 0.0f
	方法 取位图() : 位图对象
		返回 位图序列.访问()
	结束 方法
	方法 初始化(ic : 场景)
		订阅事件()
		计数.最大计数 = 10
		高度 = ic.网格大小
		宽度 = ic.网格大小
		位置.x = 0 - ic.网格大小
		位置.y = 0 - ic.网格大小
		变量 tempjil : JSON数组 = [[
			[
				"gb01.png",
				"gb02.png",
				"gb03.png",
				"gb03.png",
				"gb03.png",
				"gb02.png",
				"gb01.png"
			]
		]]
		循环(i, 0, tempjil.长度)
			位图序列.添加(位图对象.创建缩放位图(ic.数据管理.取位图(tempjil.取文本(i)),ic.网格大小,ic.网格大小,真))
		结束 循环
	结束 方法
	事件 计数 : 触发()
		位图序列.下一张()
	结束 事件
结束 类